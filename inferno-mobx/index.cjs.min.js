"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("mobx"),t=require("inferno"),r=require("hoist-non-inferno-statics");function n(e){return e&&"object"===typeof e&&"default"in e?e:{default:e}}var o=n(r),i=function(){this.listeners=[]};function s(e){console.error(e)}function p(e){return!(e.prototype&&e.prototype.render)}i.prototype.on=function(e){var t=this;return this.listeners.push(e),function(){var r=t.listeners.indexOf(e);-1!==r&&t.listeners.splice(r,1)}},i.prototype.emit=function(e){for(var t=this.listeners,r=0,n=t.length;r<n;++r)t[r](e)};var a=!1,c=!1,u=!1,f=new i;function l(e){var t=e.$LI.dom;f.emit({component:e,event:"render",node:t,renderTime:e.__$mobRenderEnd-e.__$mobRenderStart,totalTime:Date.now()-e.__$mobRenderStart})}function d(){a?(a=!1,f.listeners.length=0):(a=!0,s("Do not turn trackComponents on in production, its expensive. For tracking dom nodes you need inferno-compat."))}function m(e){c=e}var h=new i;function v(e,t,r){var n=e[t],o=b[t],i=n?!0===r?function(){o.apply(this,arguments),n.apply(this,arguments)}:function(){n.apply(this,arguments),o.apply(this,arguments)}:o;e[t]=i}function y(e,t){if(null==e||null==t||"object"!==typeof e||"object"!==typeof t)return e!==t;var r,n=Object.keys(e);if(n.length!==Object.keys(t).length)return!0;for(var o=n.length-1;o>=0;o--)if(t[r=n[o]]!==e[r])return!0;return!1}var b={componentWillMount:function(){var t=this;if(!0===c)return;var r=this.displayName||this.name||this.constructor&&(this.constructor.displayName||this.constructor.name)||"<component>",n=!1;function o(t){var r=this[t],o=e.createAtom("reactive "+t);Object.defineProperty(this,t,{configurable:!0,enumerable:!0,get:function(){return o.reportObserved(),r},set:function(e){y(r,e)?(r=e,n=!0,o.reportChanged(),n=!1):r=e}})}o.call(this,"props"),o.call(this,"state");var i=this,s=this.render.bind(this),p=function(){return s(i.props,i.state,i.context)},u=null,f=!1,l=function(){var r;f=!1;var n=null;if(u.track((function(){a&&(t.__$mobRenderStart=Date.now());try{n=e._allowStateChanges(!1,p)}catch(e){r=e}a&&(t.__$mobRenderEnd=Date.now())})),r)throw h.emit(r),r;return n};this.render=function(){return(u=new e.Reaction(r+".render()",(function(){f||(f=!0,"function"===typeof t.componentWillReact&&t.componentWillReact(),n||t.forceUpdate())}))).reactComponent=t,l.$mobx=u,t.render=l,l()}},componentWillUnmount:function(){if(!0===c)return;if(this.render.$mobx&&this.render.$mobx.dispose(),a){var e=this.$LI.dom;f.emit({component:this,event:"destroy",node:e})}},componentDidMount:function(){a&&l(this)},componentDidUpdate:function(){a&&l(this)},shouldComponentUpdate:function(e,t){if(c&&s("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."),this.state!==t)return!0;return y(this.props,e)}};function x(e,r){var n;if("string"===typeof e)throw new Error("Store names should be provided as array");if(Array.isArray(e))return u||(u=!0,s('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject("store1", "store2") @observer ComponentClass` or `inject("store1", "store2")(observer(componentClass))` instead of `@observer(["store1", "store2"]) ComponentClass`')),r?R.apply(null,e)(x(r)):function(t){return x(e,t)};var o=e;if(!0===o.isMobxInjector&&s("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'"),"function"===typeof o&&(!o.prototype||!o.prototype.render))return x(((n=function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(e,t,r){return o(e,r)},t}(t.Component)).displayName=o.displayName||o.name,n.defaultProps=o.defaultProps,n));if(!o)throw new Error("Please pass a valid component to 'observer'");return _(o.prototype||o),o.isMobXReactObserver=!0,o}function _(e){v(e,"componentWillMount",!0),v(e,"componentDidMount",!1),v(e,"componentWillUnmount",!1),v(e,"componentDidUpdate",!1),e.shouldComponentUpdate||(e.shouldComponentUpdate=b.shouldComponentUpdate)}var g=x((function(e){return(0,e.children)()}));g.displayName="Observer";var j={isMobxInjector:{configurable:!0,enumerable:!0,value:!0,writable:!0}};function C(e,r,n){var i="inject-"+(r.displayName||r.name||r.constructor&&r.constructor.name||"Unknown");n&&(i+="-with-"+n);var s=function(n){function o(e,t){n.call(this,e,t),this.storeRef=this.storeRef.bind(this)}return n&&(o.__proto__=n),o.prototype=Object.create(n&&n.prototype),o.prototype.constructor=o,o.prototype.storeRef=function(e){this.wrappedInstance=e},o.prototype.render=function(n,o,i){var s,a={};for(s in n)a[s]=n[s];var c=e(i.mobxStores||{},a,i)||{};for(s in c)a[s]=c[s];return t.createComponentVNode(2,r,a,null,p(r)?null:this.storeRef)},o}(t.Component);return s.displayName=i,s.isMobxInjector=!1,o.default(s,r),s.wrappedComponent=r,Object.defineProperties(s,j),s}function w(e){return function(t,r){for(var n=0,o=e.length;n<o;++n){var i=e[n];i in r||(r[i]=t[i])}return r}}function R(){var e,t=arguments;if("function"===typeof arguments[0])return e=arguments[0],function(t){var r=C(e,t);return r.isMobxInjector=!1,(r=x(r)).isMobxInjector=!0,r};for(var r=[],n=0;n<arguments.length;++n)r.push(t[n]);return e=w(r),function(t){return C(e,t,r.join("-"))}}var M={children:!0,key:!0,ref:!0},O=function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(e){return e.children},t.prototype.getChildContext=function(){var e={},t=this.props,r=this.context.mobxStores;if(r)for(var n in r)e[n]=r[n];for(var o in t)void 0===M[o]&&"suppressChangedStoreWarning"!==o&&(e[o]=t[o]);return{mobxStores:e}},t}(t.Component),U=function(e){return h.on(e)};exports.EventEmitter=i,exports.Observer=g,exports.Provider=O,exports.errorsReporter=h,exports.inject=R,exports.observer=x,exports.onError=U,exports.renderReporter=f,exports.trackComponents=d,exports.useStaticRendering=m;
